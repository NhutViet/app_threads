import type { Clerk } from './resources/internal';
/**
 * TODO: @nikos Move captcha and fraud detection logic to this class
 */
declare class FraudProtectionService {
    private inflightRequest;
    private ticks;
    private readonly interval;
    execute<T extends () => Promise<any>>(cb: T): Promise<Awaited<ReturnType<T>>>;
    blockUntilReady(): Promise<void> | Promise<null>;
    challengeHeartbeat(clerk: Clerk): Promise<{
        captchaToken: string;
        captchaWidgetType: import("@clerk/types").CaptchaWidgetType;
    } | undefined>;
    /**
     * Triggers an invisible challenge.
     * This will always use the non-interactive variant of the CAPTCHA challenge and will
     * always use the fallback key.
     */
    invisibleChallenge(clerk: Clerk): Promise<{
        captchaToken: string;
        captchaWidgetType: import("@clerk/types").CaptchaWidgetType;
    } | undefined>;
    /**
     * Triggers a smart challenge if the user is required to solve a CAPTCHA.
     * Depending on the environment settings, this will either trigger an
     * invisible or smart (managed) CAPTCHA challenge.
     * Managed challenged start as non-interactive and escalate to interactive if necessary.
     * Important: For this to work at the moment, the instance needs to be using SMART protection
     * as we need both keys (visible and invisible) to be present.
     */
    managedChallenge(clerk: Clerk): Promise<{}>;
}
export declare const fraudProtection: FraudProtectionService;
export {};
